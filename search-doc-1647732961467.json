[{"title":"extras","type":0,"sectionRef":"#","url":"docs/","content":"extras Project\tMaven Centralextras-cats extras-scala-io extras-concurrent extras-concurrent-testing extras-hedgehog-cats-effect3 extras-reflects extras-refinement info Supported Scala Versions: 3, 2.13, 2.12 and 2.11 For more details: Supported version matrix extras-catsextras-scala-ioextras-concurrentextras-hedgehog-cats-effect3extras-reflects (n/a to Scala 3)extras-refinement (n/a to Scala 3)","keywords":""},{"title":"Get extras-cats","type":0,"sectionRef":"#","url":"docs/extras-cats/getting-started","content":"Get extras-cats \"io.kevinlee\" %% \"extras-cats\" % \"0.11.0\" Copy","keywords":""},{"title":"EitherT","type":0,"sectionRef":"#","url":"docs/extras-cats/eithert","content":"","keywords":""},{"title":"Extension Methods for EitherT​","type":1,"pageTitle":"EitherT","url":"docs/extras-cats/eithert#extension-methods-for-eithert","content":"import extras.cats.syntax.either._ Copy or import extras.cats.syntax.all._ Copy "},{"title":"eitherT / t for F[Either[A, B]]​","type":1,"pageTitle":"EitherT","url":"docs/extras-cats/eithert#eithert--t-for-feithera-b","content":"When you have fab: F[Either[A, B]], instead of EitherT(fab), you can simply do fab.eitherT // EitherT[F, A, B] // or fab.t // EitherT[F, A, B] Copy import cats.syntax.all._ import cats.effect._ import extras.cats.syntax.all._ val fab = IO.pure(1.asRight[String]) // fab: IO[Either[String, Int]] = Pure(a = Right(value = 1)) fab.t // res1: cats.data.EitherT[IO, String, Int] = EitherT( // value = Pure(a = Right(value = 1)) // ) val f = IO(println(\"Hello\").asRight[String]) // f: IO[Either[String, Unit]] = Delay( // thunk = <function0>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO$.delay(IO.scala:1176), // cats.effect.IO$.apply(IO.scala:1144), // repl.MdocSession$App0$.<clinit>(eithert.md:26), // repl.MdocSession$App.<init>(eithert.md:5), // repl.MdocSession$.app(eithert.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ) f.t // res2: cats.data.EitherT[IO, String, Unit] = EitherT( // value = Delay( // thunk = <function0>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO$.delay(IO.scala:1176), // cats.effect.IO$.apply(IO.scala:1144), // repl.MdocSession$App0$.<clinit>(eithert.md:26), // repl.MdocSession$App.<init>(eithert.md:5), // repl.MdocSession$.app(eithert.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ) // ) Copy "},{"title":"eitherT / t for Either[A, B]​","type":1,"pageTitle":"EitherT","url":"docs/extras-cats/eithert#eithert--t-for-eithera-b","content":"When you have ab: Either[A, B], instead of EitherT.fromEither[F](ab), you can simply do ab.eitherT[F] // EitherT[F, A, B] // or ab.t[F] // EitherT[F, A, B] Copy import cats.syntax.all._ import cats.effect._ import extras.cats.syntax.all._ val ab = 1.asRight[String] // ab: Either[String, Int] = Right(value = 1) ab.t[IO] // res4: cats.data.EitherT[IO, String, Int] = EitherT( // value = Pure(a = Right(value = 1)) // ) Copy "},{"title":"rightT for F[B]​","type":1,"pageTitle":"EitherT","url":"docs/extras-cats/eithert#rightt-for-fb","content":"When you have fb: F[B], instead of EitherT.right[A](fb), you can simply do fb.rightT[A] // EitherT[F, A, B] Copy import cats.effect._ import extras.cats.syntax.all._ val fb = IO.pure(1) // fb: IO[Int] = Pure(a = 1) fb.rightT[String] // res6: cats.data.EitherT[IO, String, Int] = EitherT( // value = Map( // source = Pure(a = 1), // f = cats.data.EitherT$RightPartiallyApplied$$$Lambda$8173/0x00000001023cf840@69cd6f4c, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:872), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:865), // cats.data.EitherT$RightPartiallyApplied$.apply$extension(EitherT.scala:694), // extras.cats.syntax.EitherSyntax$EitherTFAOps$.rightT$extension(EitherSyntax.scala:37), // repl.MdocSession$App5$.<clinit>(eithert.md:68), // repl.MdocSession$App3$.<clinit>(eithert.md:53), // repl.MdocSession$App0$.<clinit>(eithert.md:32), // repl.MdocSession$App.<init>(eithert.md:5), // repl.MdocSession$.app(eithert.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ) // ) val f = IO(println(\"Hello\")) // f: IO[Unit] = Delay( // thunk = <function0>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO$.delay(IO.scala:1176), // cats.effect.IO$.apply(IO.scala:1144), // repl.MdocSession$App5$.<clinit>(eithert.md:71), // repl.MdocSession$App3$.<clinit>(eithert.md:53), // repl.MdocSession$App0$.<clinit>(eithert.md:32), // repl.MdocSession$App.<init>(eithert.md:5), // repl.MdocSession$.app(eithert.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ) f.rightT[String] // res7: cats.data.EitherT[IO, String, Unit] = EitherT( // value = Map( // source = Delay( // thunk = <function0>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO$.delay(IO.scala:1176), // cats.effect.IO$.apply(IO.scala:1144), // repl.MdocSession$App5$.<clinit>(eithert.md:71), // repl.MdocSession$App3$.<clinit>(eithert.md:53), // repl.MdocSession$App0$.<clinit>(eithert.md:32), // repl.MdocSession$App.<init>(eithert.md:5), // repl.MdocSession$.app(eithert.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ), // f = cats.data.EitherT$RightPartiallyApplied$$$Lambda$8173/0x00000001023cf840@69cd6f4c, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:872), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:865), // cats.data.EitherT$RightPartiallyApplied$.apply$extension(EitherT.scala:694), // ... Copy "},{"title":"leftT for F[A]​","type":1,"pageTitle":"EitherT","url":"docs/extras-cats/eithert#leftt-for-fa","content":"When you have fa: F[A], instead of EitherT.left[B](fa), you can simply do fa.leftT[B] // EitherT[F, A, B] Copy import cats.effect._ import extras.cats.syntax.all._ val fa = IO.pure(\"ERROR!!!\") // fa: IO[String] = Pure(a = \"ERROR!!!\") fa.leftT[Int] // res9: cats.data.EitherT[IO, String, Int] = EitherT( // value = Map( // source = Pure(a = \"ERROR!!!\"), // f = cats.data.EitherT$LeftPartiallyApplied$$$Lambda$8174/0x00000001023ce840@67d2e738, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:872), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:865), // cats.data.EitherT$LeftPartiallyApplied$.apply$extension(EitherT.scala:658), // extras.cats.syntax.EitherSyntax$EitherTFAOps$.leftT$extension(EitherSyntax.scala:38), // repl.MdocSession$App8$.<clinit>(eithert.md:92), // repl.MdocSession$App5$.<clinit>(eithert.md:77), // repl.MdocSession$App3$.<clinit>(eithert.md:53), // repl.MdocSession$App0$.<clinit>(eithert.md:32), // repl.MdocSession$App.<init>(eithert.md:5), // repl.MdocSession$.app(eithert.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ) // ) val f = IO(println(\"ERROR!!!\")) // f: IO[Unit] = Delay( // thunk = <function0>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO$.delay(IO.scala:1176), // cats.effect.IO$.apply(IO.scala:1144), // repl.MdocSession$App8$.<clinit>(eithert.md:95), // repl.MdocSession$App5$.<clinit>(eithert.md:77), // repl.MdocSession$App3$.<clinit>(eithert.md:53), // repl.MdocSession$App0$.<clinit>(eithert.md:32), // repl.MdocSession$App.<init>(eithert.md:5), // repl.MdocSession$.app(eithert.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ) f.leftT[Int] // res10: cats.data.EitherT[IO, Unit, Int] = EitherT( // value = Map( // source = Delay( // thunk = <function0>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO$.delay(IO.scala:1176), // cats.effect.IO$.apply(IO.scala:1144), // repl.MdocSession$App8$.<clinit>(eithert.md:95), // repl.MdocSession$App5$.<clinit>(eithert.md:77), // repl.MdocSession$App3$.<clinit>(eithert.md:53), // repl.MdocSession$App0$.<clinit>(eithert.md:32), // repl.MdocSession$App.<init>(eithert.md:5), // repl.MdocSession$.app(eithert.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ), // f = cats.data.EitherT$LeftPartiallyApplied$$$Lambda$8174/0x00000001023ce840@67d2e738, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:872), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:865), // cats.data.EitherT$LeftPartiallyApplied$.apply$extension(EitherT.scala:65... Copy "},{"title":"Example​","type":1,"pageTitle":"EitherT","url":"docs/extras-cats/eithert#example","content":"import cats.syntax.all._ import cats.effect._ import extras.cats.syntax.all._ final case class MyError(message: String) def foo[F[_]: Sync](n: Int): F[Int] = Sync[F].pure(n * 2) def bar[F[_]: Sync](n: Int): F[Either[MyError, Int]] = if (n < 0) Sync[F].pure(MyError(s\"n cannot be a negative number. [n: $n]\").asLeft) else Sync[F].pure((n + 100).asRight) def divide[F[_]: Sync](a: Int, b: Int): F[Either[MyError, Int]] = if (b == 0) MyError(s\"You can divide number by 0. [a: $a, b: $b]\").asLeft.pure[F] else Sync[F].delay((a / b).asRight) def run[F[_]: Sync](): F[Either[MyError, Int]] = (for { a <- foo(123).rightT b <- 2.rightTF[F, MyError] c <- bar(b).eitherT d <- divide(a, b).t } yield d).value println(run[IO]().unsafeRunSync()) // Right(123) Copy "},{"title":"OptionT","type":0,"sectionRef":"#","url":"docs/extras-cats/optiont","content":"","keywords":""},{"title":"Extension Methods for OptionT​","type":1,"pageTitle":"OptionT","url":"docs/extras-cats/optiont#extension-methods-for-optiont","content":"import extras.cats.syntax.option._ Copy or import extras.cats.syntax.all._ Copy "},{"title":"optionT / t for F[Option[A]]​","type":1,"pageTitle":"OptionT","url":"docs/extras-cats/optiont#optiont--t-for-foptiona","content":"When you have foa: F[Option[A]], instead of OptionT(foa), you can simply do foa.optionT // OptionT[F, A] // or foa.t // OptionT[F, A] Copy import cats.syntax.all._ import cats.effect._ import extras.cats.syntax.all._ val foa = IO.pure(1.some) // foa: IO[Option[Int]] = Pure(a = Some(value = 1)) foa.t // res1: cats.data.OptionT[IO, Int] = OptionT( // value = Pure(a = Some(value = 1)) // ) val f = IO(println(\"Hello\").some) // f: IO[Option[Unit]] = Delay( // thunk = <function0>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO$.delay(IO.scala:1176), // cats.effect.IO$.apply(IO.scala:1144), // repl.MdocSession$App0$.<clinit>(optiont.md:26), // repl.MdocSession$App.<init>(optiont.md:5), // repl.MdocSession$.app(optiont.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ) f.t // res2: cats.data.OptionT[IO, Unit] = OptionT( // value = Delay( // thunk = <function0>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO$.delay(IO.scala:1176), // cats.effect.IO$.apply(IO.scala:1144), // repl.MdocSession$App0$.<clinit>(optiont.md:26), // repl.MdocSession$App.<init>(optiont.md:5), // repl.MdocSession$.app(optiont.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ) // ) Copy "},{"title":"optionT / t for Option[A]​","type":1,"pageTitle":"OptionT","url":"docs/extras-cats/optiont#optiont--t-for-optiona","content":"When you have oa: Option[A], instead of OptionT.fromOption[F](oa), you can simply do oa.optionT[F] // OptionT[F, A] // or oa.t[F] // OptionT[F, A] Copy import cats.syntax.all._ import cats.effect._ import extras.cats.syntax.all._ val oa = 1.some // oa: Option[Int] = Some(value = 1) oa.t[IO] // res4: cats.data.OptionT[IO, Int] = OptionT( // value = Pure(a = Some(value = 1)) // ) Copy "},{"title":"someT for F[A]​","type":1,"pageTitle":"OptionT","url":"docs/extras-cats/optiont#somet-for-fa","content":"When you have fa: F[A], instead of OptionT.liftF(fa), you can simply do fa.someT // OptionT[F, A] Copy import cats.effect._ import extras.cats.syntax.all._ val fa = IO.pure(1) // fa: IO[Int] = Pure(a = 1) fa.someT // res6: cats.data.OptionT[IO, Int] = OptionT( // value = Map( // source = Pure(a = 1), // f = cats.data.OptionT$$$Lambda$8254/0x000000010243f040@52628910, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:872), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:865), // cats.data.OptionT$.liftF(OptionT.scala:249), // extras.cats.syntax.OptionSyntax$OptionTFAOps$.someT$extension(OptionSyntax.scala:37), // repl.MdocSession$App5$.<clinit>(optiont.md:68), // repl.MdocSession$App3$.<clinit>(optiont.md:53), // repl.MdocSession$App0$.<clinit>(optiont.md:32), // repl.MdocSession$App.<init>(optiont.md:5), // repl.MdocSession$.app(optiont.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ) // ) val f = IO(println(\"Hello\")) // f: IO[Unit] = Delay( // thunk = <function0>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO$.delay(IO.scala:1176), // cats.effect.IO$.apply(IO.scala:1144), // repl.MdocSession$App5$.<clinit>(optiont.md:71), // repl.MdocSession$App3$.<clinit>(optiont.md:53), // repl.MdocSession$App0$.<clinit>(optiont.md:32), // repl.MdocSession$App.<init>(optiont.md:5), // repl.MdocSession$.app(optiont.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ) f.someT // res7: cats.data.OptionT[IO, Unit] = OptionT( // value = Map( // source = Delay( // thunk = <function0>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO$.delay(IO.scala:1176), // cats.effect.IO$.apply(IO.scala:1144), // repl.MdocSession$App5$.<clinit>(optiont.md:71), // repl.MdocSession$App3$.<clinit>(optiont.md:53), // repl.MdocSession$App0$.<clinit>(optiont.md:32), // repl.MdocSession$App.<init>(optiont.md:5), // repl.MdocSession$.app(optiont.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ), // f = cats.data.OptionT$$$Lambda$8254/0x000000010243f040@52628910, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:872), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:865), // cats.data.OptionT$.liftF(OptionT.scala:249), // extras.cats.syntax.OptionSyntax$OptionTFAOps$.someT$extension(OptionSyntax.scala:37), // ... Copy "},{"title":"someTF for A​","type":1,"pageTitle":"OptionT","url":"docs/extras-cats/optiont#sometf-for-a","content":"When you have a: A, instead of OptionT.some(a), you can simply do a.someTF[F] // OptionT[F, A] Copy import cats.effect._ import extras.cats.syntax.all._ val a = 1 // a: Int = 1 a.someTF[IO] // res9: cats.data.OptionT[IO, Int] = OptionT( // value = Pure(a = Some(value = 1)) // ) Copy "},{"title":"Example​","type":1,"pageTitle":"OptionT","url":"docs/extras-cats/optiont#example","content":"import cats.syntax.all._ import cats.effect._ import extras.cats.syntax.all._ final case class MyError(message: String) def foo[F[_]: Sync](n: Int): F[Int] = Sync[F].pure(n * 2) def bar[F[_]: Sync](n: Int): F[Option[Int]] = if (n < 0) Sync[F].pure(none[Int]) else Sync[F].pure((n + 100).some) def divide[F[_]: Sync](a: Int, b: Int): F[Option[Int]] = if (b == 0) none[Int].pure[F] else Sync[F].delay((a / b).some) def run[F[_]: Sync](): F[Option[Int]] = (for { a <- foo(123).someT b <- 2.someTF[F] c <- bar(b).optionT d <- divide(a, b).t } yield d).value println(run[IO]().unsafeRunSync()) // Some(123) Copy "},{"title":"Concurrent","type":0,"sectionRef":"#","url":"docs/extras-concurrent/concurrent","content":"Concurrent","keywords":""},{"title":"Get extras-hedgehog-cats-effect3","type":0,"sectionRef":"#","url":"docs/extras-hedgehog-cats-effect3/getting-started","content":"Get extras-hedgehog-cats-effect3 extras-hedgehog-cats-effect3 provides some helper tools to write tests with hedgehog and cats-effect 3. \"io.kevinlee\" %% \"extras-hedgehog-cats-effect3\" % \"0.11.0\" Copy","keywords":""},{"title":"Get extras-concurrent","type":0,"sectionRef":"#","url":"docs/extras-concurrent/getting-started","content":"","keywords":""},{"title":"Get extras-concurrent​","type":1,"pageTitle":"Get extras-concurrent","url":"docs/extras-concurrent/getting-started#get-extras-concurrent-1","content":"\"io.kevinlee\" %% \"extras-concurrent\" % \"0.11.0\" Copy "},{"title":"Get extras-concurrent-testing​","type":1,"pageTitle":"Get extras-concurrent","url":"docs/extras-concurrent/getting-started#get-extras-concurrent-testing","content":"\"io.kevinlee\" %% \"extras-concurrent-testing\" % \"0.11.0\" % Test Copy "},{"title":"Usage​","type":1,"pageTitle":"Get extras-concurrent","url":"docs/extras-concurrent/getting-started#usage","content":""},{"title":"Test with cats-effect 3 IO","type":0,"sectionRef":"#","url":"docs/extras-hedgehog-cats-effect3/test-with-io","content":"","keywords":""},{"title":"completeThen​","type":1,"pageTitle":"Test with cats-effect 3 IO","url":"docs/extras-hedgehog-cats-effect3/test-with-io#completethen","content":"Use CatsEffectRunner and completeThen instead of unsafeRunSync(). import cats.effect._ import extras.hedgehog.cats.effect.CatsEffectRunner import hedgehog._ import hedgehog.runner._ object SomeSpec extends Properties { override def tests: List[Test] = List( property(\"test with CatsEffectRunner and completeThen\", testCatsEffectRunnerWithCompleteThen) ) def testCatsEffectRunnerWithCompleteThen: Property = for { n <- Gen.int(Range.linear(Int.MinValue, Int.MaxValue)).log(\"n\") } yield { import CatsEffectRunner._ implicit val ticker: Ticker = Ticker.withNewTestContext() val expected = n val actual = IO(n) actual.completeThen { actual => actual ==== expected } } } Copy "},{"title":"errorThen​","type":1,"pageTitle":"Test with cats-effect 3 IO","url":"docs/extras-hedgehog-cats-effect3/test-with-io#errorthen","content":"If you want to test with IO which may result in some Exception thrown, you can use errorThen instead of unsafeRunSync() and Try. import cats.effect._ import extras.hedgehog.cats.effect.CatsEffectRunner import hedgehog._ import hedgehog.runner._ object SomeSpec extends Properties { override def tests: List[Test] = List( property(\"test with CatsEffectRunner and errorThen\", testCatsEffectRunnerWithErrorThen) ) def testCatsEffectRunnerWithErrorThen: Property = for { message <- Gen.string(Gen.alphaNum, Range.linear(1, 10)).log(\"message\") error <- Gen .element1( TestError.someTestError(s\"Don't worry it's only a test error. $message\"), TestError.anotherTestError(s\"Don't worry it's only a test error. $message\") ) .log(\"error\") } yield { import CatsEffectRunner._ implicit val ticker: Ticker = Ticker.withNewTestContext() val expected = error val actual = IO.raiseError[Int](error) actual.errorThen { actual => actual ==== expected } } sealed abstract class TestError(val message: String) extends RuntimeException(message) object TestError { final case class SomeTestError(override val message: String) extends TestError(message) final case class AnotherTestError(override val message: String) extends TestError(message) def anotherTestError(message: String): TestError = AnotherTestError(message) def someTestError(message: String): TestError = SomeTestError(message) } } Copy "},{"title":"Get extras-refinement","type":0,"sectionRef":"#","url":"docs/extras-refinement/getting-started","content":"Get extras-refinement extras-refinement provides syntax to use newtype and refined. \"io.kevinlee\" %% \"extras-refinement\" % \"0.11.0\" Copy","keywords":""},{"title":"Get extras-reflects","type":0,"sectionRef":"#","url":"docs/extras-reflects/getting-started","content":"Get extras-reflects extras-reflects provides convenient syntax to use scala-reflect. \"io.kevinlee\" %% \"extras-reflects\" % \"0.11.0\" Copy","keywords":""},{"title":"Refinement Syntax","type":0,"sectionRef":"#","url":"docs/extras-refinement/syntax","content":"","keywords":""},{"title":"Why refinement syntax?​","type":1,"pageTitle":"Refinement Syntax","url":"docs/extras-refinement/syntax#why-refinement-syntax","content":"When you use newtype and refined together to have better type-safety, you often have some boilerplate code for runtime value validation when creating newtype + refinement type just like this. YourRefinementType.from(value) .toEither .map(YourNewtype(_)) .leftMap(err => s\"Failed to create YourNewtype: $err\") Copy In practice, it may look like import cats.syntax.all._ import io.estatico.newtype.macros.newtype import eu.timepit.refined.types.string.NonEmptyString @newtype case class Name(value: NonEmptyString) val validNameValue = \"Kevin\" // validNameValue: String = \"Kevin\" NonEmptyString.from(validNameValue) .toEitherNel .map(Name(_)) .leftMap(err => s\"Failed to create Name: $err\") // res1: Either[String, Name] = Right(value = Kevin) val invalidNameValue = \"\" // invalidNameValue: String = \"\" NonEmptyString.from(invalidNameValue) .toEitherNel .map(Name(_)) .leftMap(err => s\"Failed to create Name: $err\") // res2: Either[String, Name] = Left( // value = \"Failed to create Name: NonEmptyList(Predicate isEmpty() did not fail.)\" // ) Copy or this import cats.syntax.all._ import eu.timepit.refined.api._ import eu.timepit.refined.numeric._ import eu.timepit.refined.types.string.NonEmptyString import io.estatico.newtype.macros.newtype import io.estatico.newtype.ops._ object Types { type PositiveInt = Int Refined Positive object PositiveInt extends RefinedTypeOps[PositiveInt, Int] @newtype case class Id(value: PositiveInt) @newtype case class Name(value: NonEmptyString) final case class Person(id: Id, name: Name) } import Types._ val idValue = 999 // idValue: Int = 999 val id = PositiveInt.from(idValue) .toEitherNel .map(Id(_)) .leftMap(err => s\"Failed to create Types.Id: $err\") // id: Either[String, Id] = Right(value = 999) println(id) // Right(999) val nameValue = \"Kevin\" // nameValue: String = \"Kevin\" val name = NonEmptyString.from(nameValue) .toEitherNel .map(Name(_)) .leftMap(err => s\"Failed to create Types.Name: $err\") // name: Either[String, Name] = Right(value = Kevin) println(name) // Right(Kevin) val person = (id, name).parMapN(Person.apply) // person: Either[String, Person] = Right( // value = Person(id = 999, name = Kevin) // ) println(person) // Right(Person(999,Kevin)) Copy "},{"title":"refinement syntax​","type":1,"pageTitle":"Refinement Syntax","url":"docs/extras-refinement/syntax#refinement-syntax","content":"The boilerplate code issue in newtype + refinement type creation can be fixed with extras refinement syntax so the following code snippet YourRefinementType.from(value) .toEither .map(YourNewtype(_)) .leftMap(err => s\"Failed to create YourNewtype: $err\") Copy becomes just validateAs[YourNewtype](value) Copy or value.validateAs[YourNewtype] Copy note The idea of validateAs[A](value) and value.validateAs[A] is from Practical FP in Scala. The syntax is not exactly the same, but the most important core logic of using Coercible is the same. "},{"title":"Example: Valid Case​","type":1,"pageTitle":"Refinement Syntax","url":"docs/extras-refinement/syntax#example-valid-case","content":"import cats.syntax.all._ import eu.timepit.refined.api._ import eu.timepit.refined.numeric._ import eu.timepit.refined.types.string.NonEmptyString import io.estatico.newtype.macros.newtype import extras.refinement.syntax.refinement._ object Types { type PositiveInt = Int Refined Positive object PositiveInt extends RefinedTypeOps[PositiveInt, Int] @newtype case class Id(value: PositiveInt) @newtype case class Name(value: NonEmptyString) final case class Person(id: Id, name: Name) } import Types._ val idValue = 999 // idValue: Int = 999 val id = validateAs[Id](idValue) // id: cats.data.package.EitherNec[String, Id] = Right(value = 999) val id2 = idValue.validateAs[Id] // id2: cats.data.package.EitherNec[String, Id] = Right(value = 999) println(id) // Right(999) println(id2) // Right(999) val nameValue = \"Kevin\" // nameValue: String = \"Kevin\" val name = validateAs[Name](nameValue) // name: cats.data.package.EitherNec[String, Name] = Right(value = Kevin) val name2 = nameValue.validateAs[Name] // name2: cats.data.package.EitherNec[String, Name] = Right(value = Kevin) println(name) // Right(Kevin) println(name2) // Right(Kevin) val person = (id, name).parMapN(Person.apply) // person: cats.data.package.EitherNec[String, Person] = Right( // value = Person(id = 999, name = Kevin) // ) println(person) // Right(Person(999,Kevin)) Copy "},{"title":"Example: Invalid Case​","type":1,"pageTitle":"Refinement Syntax","url":"docs/extras-refinement/syntax#example-invalid-case","content":"Only of them is invalid​ import cats.syntax.all._ import eu.timepit.refined.api._ import eu.timepit.refined.numeric._ import eu.timepit.refined.types.string.NonEmptyString import io.estatico.newtype.macros.newtype import extras.refinement.syntax.refinement._ object Types { type PositiveInt = Int Refined Positive object PositiveInt extends RefinedTypeOps[PositiveInt, Int] @newtype case class Id(value: PositiveInt) @newtype case class Name(value: NonEmptyString) final case class Person(id: Id, name: Name) } import Types._ val idValue = 0 // idValue: Int = 0 val id = validateAs[Id](idValue) // id: cats.data.package.EitherNec[String, Id] = Left( // value = Singleton(a = \"Failed to create Types.Id: Predicate failed: (0 > 0).\") // ) val id2 = idValue.validateAs[Id] // id2: cats.data.package.EitherNec[String, Id] = Left( // value = Singleton(a = \"Failed to create Types.Id: Predicate failed: (0 > 0).\") // ) println(id) // Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0).)) println(id2) // Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0).)) val nameValue = \"Kevin\" // nameValue: String = \"Kevin\" val name = validateAs[Name](nameValue) // name: cats.data.package.EitherNec[String, Name] = Right(value = Kevin) val name2 = nameValue.validateAs[Name] // name2: cats.data.package.EitherNec[String, Name] = Right(value = Kevin) println(name) // Right(Kevin) println(name2) // Right(Kevin) val person = (id, name).parMapN(Person.apply) // person: cats.data.package.EitherNec[String, Person] = Left( // value = Singleton(a = \"Failed to create Types.Id: Predicate failed: (0 > 0).\") // ) println(person) // Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0).)) Copy The other one is invalid​ import cats.syntax.all._ import eu.timepit.refined.api._ import eu.timepit.refined.numeric._ import eu.timepit.refined.types.string.NonEmptyString import io.estatico.newtype.macros.newtype import extras.refinement.syntax.refinement._ object Types { type PositiveInt = Int Refined Positive object PositiveInt extends RefinedTypeOps[PositiveInt, Int] @newtype case class Id(value: PositiveInt) @newtype case class Name(value: NonEmptyString) final case class Person(id: Id, name: Name) } import Types._ val idValue = 999 // idValue: Int = 999 val id = validateAs[Id](idValue) // id: cats.data.package.EitherNec[String, Id] = Right(value = 999) val id2 = idValue.validateAs[Id] // id2: cats.data.package.EitherNec[String, Id] = Right(value = 999) println(id) // Right(999) println(id2) // Right(999) val nameValue = \"\" // nameValue: String = \"\" val name = validateAs[Name](nameValue) // name: cats.data.package.EitherNec[String, Name] = Left( // value = Singleton( // a = \"Failed to create Types.Name: Predicate isEmpty() did not fail.\" // ) // ) val name2 = nameValue.validateAs[Name] // name2: cats.data.package.EitherNec[String, Name] = Left( // value = Singleton( // a = \"Failed to create Types.Name: Predicate isEmpty() did not fail.\" // ) // ) println(name) // Left(Chain(Failed to create Types.Name: Predicate isEmpty() did not fail.)) println(name2) // Left(Chain(Failed to create Types.Name: Predicate isEmpty() did not fail.)) val person = (id, name).parMapN(Person.apply) // person: cats.data.package.EitherNec[String, Person] = Left( // value = Singleton( // a = \"Failed to create Types.Name: Predicate isEmpty() did not fail.\" // ) // ) println(person) // Left(Chain(Failed to create Types.Name: Predicate isEmpty() did not fail.)) Copy More than one invalid​ import cats.syntax.all._ import eu.timepit.refined.api._ import eu.timepit.refined.numeric._ import eu.timepit.refined.types.string.NonEmptyString import io.estatico.newtype.macros.newtype import extras.refinement.syntax.refinement._ object Types { type PositiveInt = Int Refined Positive object PositiveInt extends RefinedTypeOps[PositiveInt, Int] @newtype case class Id(value: PositiveInt) @newtype case class Name(value: NonEmptyString) final case class Person(id: Id, name: Name) } import Types._ val idValue = 0 // idValue: Int = 0 val id = validateAs[Id](idValue) // id: cats.data.package.EitherNec[String, Id] = Left( // value = Singleton(a = \"Failed to create Types.Id: Predicate failed: (0 > 0).\") // ) val id2 = idValue.validateAs[Id] // id2: cats.data.package.EitherNec[String, Id] = Left( // value = Singleton(a = \"Failed to create Types.Id: Predicate failed: (0 > 0).\") // ) println(id) // Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0).)) println(id2) // Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0).)) val nameValue = \"\" // nameValue: String = \"\" val name = validateAs[Name](nameValue) // name: cats.data.package.EitherNec[String, Name] = Left( // value = Singleton( // a = \"Failed to create Types.Name: Predicate isEmpty() did not fail.\" // ) // ) val name2 = nameValue.validateAs[Name] // name2: cats.data.package.EitherNec[String, Name] = Left( // value = Singleton( // a = \"Failed to create Types.Name: Predicate isEmpty() did not fail.\" // ) // ) println(name) // Left(Chain(Failed to create Types.Name: Predicate isEmpty() did not fail.)) println(name2) // Left(Chain(Failed to create Types.Name: Predicate isEmpty() did not fail.)) val person = (id, name).parMapN(Person.apply) // person: cats.data.package.EitherNec[String, Person] = Left( // value = Append( // leftNE = Singleton( // a = \"Failed to create Types.Id: Predicate failed: (0 > 0).\" // ), // rightNE = Singleton( // a = \"Failed to create Types.Name: Predicate isEmpty() did not fail.\" // ) // ) // ) println(person) // Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0)., Failed to create Types.Name: Predicate isEmpty() did not fail.)) Copy "},{"title":"Color","type":0,"sectionRef":"#","url":"docs/extras-scala-io/color","content":"","keywords":""},{"title":"extras.scala.io.syntax​","type":1,"pageTitle":"Color","url":"docs/extras-scala-io/color#extrasscalaiosyntax","content":"extras-scala-io provides syntax to use scala.io.AnsiColor easily (The missing ones will be added later). import extras.scala.io.syntax.color._ \"Hello\".blue // res1: String = \"\\u001b[34mHello\\u001b[0m\" \"Hello\".red // res2: String = \"\\u001b[31mHello\\u001b[0m\" \"Hello\".green // res3: String = \"\\u001b[32mHello\\u001b[0m\" \"Hello\".bold // res4: String = \"\\u001b[1mHello\\u001b[0m\" \"Hello\".underlined // res5: String = \"\\u001b[4mHello\\u001b[0m\" println(\"Hello\".blue) // \u001b[34mHello\u001b[0m println(\"Hello\".red) // \u001b[31mHello\u001b[0m println(\"Hello\".green) // \u001b[32mHello\u001b[0m println(\"Hello\".bold) // \u001b[1mHello\u001b[0m println(\"Hello\".underlined) // \u001b[4mHello\u001b[0m Copy  You can also chain them like this. import extras.scala.io.syntax.color._ println(\"Hello\".blue) // \u001b[34mHello\u001b[0m println(\"Hello\".blue.bold) // \u001b[1m\u001b[34mHello\u001b[0m\u001b[0m println(\"Hello\".blue.bold.underlined) // \u001b[4m\u001b[1m\u001b[34mHello\u001b[0m\u001b[0m\u001b[0m println(\"Hello\".underlined.bold.blue) // \u001b[34m\u001b[1m\u001b[4mHello\u001b[0m\u001b[0m\u001b[0m Copy  "},{"title":"Reflects Syntax","type":0,"sectionRef":"#","url":"docs/extras-reflects/syntax","content":"","keywords":""},{"title":"reflects syntax for WeakTypeTag​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#reflects-syntax-for-weaktypetag","content":""},{"title":"value.nestedTypeName​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#valuenestedtypename","content":"import java.time._ sealed trait Status object Status { final case class InProgress(startedAt: Instant) extends Status case object Done extends Status def inProgress(startedAt: Instant): Status = InProgress(startedAt) def done: Status = Done } Copy import scala.reflect.runtime.universe._ import extras.reflects.syntax.tags._ def infoWithWeakTypeTag[A: WeakTypeTag](a: A): Unit = println( s\"\"\"value: $a | type: ${weakTypeTag[A].nestedTypeName} |\"\"\".stripMargin) infoWithWeakTypeTag(Status.inProgress(Instant.now())) // value: InProgress(2022-03-19T23:35:37.827657Z) // type: App0.Status // infoWithWeakTypeTag(Status.InProgress(Instant.now())) // value: InProgress(2022-03-19T23:35:37.890510Z) // type: Status.InProgress // infoWithWeakTypeTag(Status.done) // value: Done // type: App0.Status // infoWithWeakTypeTag(Status.Done) // value: Done // type: Status.Done // Copy "},{"title":"WeakTypeTag[A].nestedTypeName​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#weaktypetaganestedtypename","content":"import java.time._ sealed trait Status object Status { final case class InProgress(startedAt: Instant) extends Status case object Done extends Status def inProgress(startedAt: Instant): Status = InProgress(startedAt) def done: Status = Done } Copy import scala.reflect.runtime.universe._ import extras.reflects.syntax.tags._ def infoWithWeakTypeTag[A](implicit weakTypeTag: WeakTypeTag[A]): Unit = println( s\"\"\"type: ${weakTypeTag.nestedTypeName} |\"\"\".stripMargin) infoWithWeakTypeTag[Status.InProgress] // type: Status.InProgress // infoWithWeakTypeTag[Status.Done.type] // type: Status.Done // println(weakTypeTag[Status.InProgress].nestedTypeName) // Status.InProgress println(weakTypeTag[Status.Done.type].nestedTypeName) // Status.Done Copy "},{"title":"Works for @newtype​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#works-for-newtype","content":"It works for newtype as well. If you use newtype and want to get the newtype name, WeakTypeTag syntax is what you should use since you can get the name of newtype with it. An example showing that it works with @newtype: import io.estatico.newtype.macros.newtype object Types { @newtype case class Id(value: Long) @newtype case class Username(value: String) } Copy import scala.reflect.runtime.universe._ import extras.reflects.syntax.tags._ Copy def infoWithClassTag[A](a: A)(implicit weakTypeTag: WeakTypeTag[A]): Unit = println( s\"\"\"value: $a | type: ${weakTypeTag.nestedTypeName} |\"\"\".stripMargin) import Types._ infoWithClassTag(Id(1L)) // value: 1 // type: Types.Id // infoWithClassTag(Username(\"someuser\")) // value: someuser // type: Types.Username // println(weakTypeTag[Id].nestedTypeName) // Types.Id println(weakTypeTag[Username].nestedTypeName) // Types.Username Copy "},{"title":"reflects syntax for ClassTag​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#reflects-syntax-for-classtag","content":""},{"title":"value.nestedRuntimeClassName​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#valuenestedruntimeclassname","content":"import java.time._ sealed trait Status object Status { final case class InProgress(startedAt: Instant) extends Status case object Done extends Status def inProgress(startedAt: Instant): Status = InProgress(startedAt) def done: Status = Done } Copy import extras.reflects.syntax.tags._ def infoWithClassTag[A](a: A): Unit = println( s\"\"\"value: $a | type: ${a.nestedRuntimeClassName} |\"\"\".stripMargin) infoWithClassTag(Status.inProgress(Instant.now())) // value: InProgress(2022-03-19T23:35:37.921108Z) // type: Status.InProgress // infoWithClassTag(Status.InProgress(Instant.now())) // value: InProgress(2022-03-19T23:35:37.924945Z) // type: Status.InProgress // infoWithClassTag(Status.done) // value: Done // type: Status.Done // infoWithClassTag(Status.Done) // value: Done // type: Status.Done // Copy println(Status.inProgress(Instant.now()).nestedRuntimeClassName) // Status.InProgress println(Status.InProgress(Instant.now()).nestedRuntimeClassName) // Status.InProgress println(Status.done.nestedRuntimeClassName) // Status.Done println(Status.Done.nestedRuntimeClassName) // Status.Done Copy "},{"title":"ClassTag[A].nestedRuntimeClassName​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#classtaganestedruntimeclassname","content":"import java.time._ sealed trait Status object Status { final case class InProgress(startedAt: Instant) extends Status case object Done extends Status def inProgress(startedAt: Instant): Status = InProgress(startedAt) def done: Status = Done } Copy import scala.reflect.{classTag, ClassTag} import extras.reflects.syntax.tags._ def infoWithClassTag[A](implicit classTag: ClassTag[A]): Unit = println( s\"\"\"type: ${classTag.nestedRuntimeClassName} |\"\"\".stripMargin) infoWithClassTag[Status.InProgress] // type: Status.InProgress // infoWithClassTag[Status.Done.type] // type: Status.Done // Copy println(classTag[Status.InProgress].nestedRuntimeClassName) // Status.InProgress println(classTag[Status.Done.type].nestedRuntimeClassName) // Status.Done Copy "},{"title":"Do not use for @newtype​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#do-not-use-for-newtype","content":"Do not use it for newtype. If you use newtype and want to get the newtype name, ClassTag syntax is not the one you should use since you can get only the actual type not newtype. For @newtype, please use 'reflects syntax for WeakTypeTag'. An example showing that it does not work with @newtype: import io.estatico.newtype.macros.newtype object Types { @newtype case class Id(value: Long) @newtype case class Username(value: String) } Copy import extras.reflects.syntax.tags._ def infoWithClassTag[A](a: A): Unit = println( s\"\"\"value: $a | type: ${a.nestedRuntimeClassName} |\"\"\".stripMargin) import Types._ infoWithClassTag(Id(1L)) // value: 1 // type: lang.Long // infoWithClassTag(Username(\"someuser\")) // value: someuser // type: lang.String // println(Id(1L).nestedRuntimeClassName) // lang.Long println(Username(\"someuser\").nestedRuntimeClassName) // lang.String Copy "},{"title":"reflects syntax for Class​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#reflects-syntax-for-class","content":""},{"title":"value.nestedClassName​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#valuenestedclassname","content":"import java.time._ sealed trait Status object Status { final case class InProgress(startedAt: Instant) extends Status case object Done extends Status def inProgress(startedAt: Instant): Status = InProgress(startedAt) def done: Status = Done } Copy import extras.reflects.syntax.classes._ def infoWithClass[A](a: A): Unit = println( s\"\"\"value: $a | type: ${a.nestedClassName} |\"\"\".stripMargin) infoWithClass(Status.inProgress(Instant.now())) // value: InProgress(2022-03-19T23:35:37.944928Z) // type: Status.InProgress // infoWithClass(Status.InProgress(Instant.now())) // value: InProgress(2022-03-19T23:35:37.947346Z) // type: Status.InProgress // infoWithClass(Status.done) // value: Done // type: Status.Done // infoWithClass(Status.Done) // value: Done // type: Status.Done // Copy println(Status.inProgress(Instant.now()).nestedClassName) // Status.InProgress println(Status.InProgress(Instant.now()).nestedClassName) // Status.InProgress println(Status.done.nestedClassName) // Status.Done println(Status.Done.nestedClassName) // Status.Done Copy "},{"title":"Class[A].nestedClassName​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#classanestedclassname","content":"import java.time._ sealed trait Status object Status { final case class InProgress(startedAt: Instant) extends Status case object Done extends Status def inProgress(startedAt: Instant): Status = InProgress(startedAt) def done: Status = Done } Copy import extras.reflects.syntax.classes._ def infoWithClass[A](aClass: Class[A]): Unit = println( s\"\"\"type: ${aClass.nestedClassName} |\"\"\".stripMargin) infoWithClass(Status.InProgress.getClass) // type: Status.InProgress // infoWithClass(Status.Done.getClass) // type: Status.Done // Copy "},{"title":"Do not use for @newtype​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#do-not-use-for-newtype-1","content":"Do not use it for newtype. If you use newtype and want to get the newtype name, Class syntax is not the one you should use since you can get only the actual type not newtype. For @newtype, please use 'reflects syntax for WeakTypeTag'. An example showing that it does not work with @newtype: import io.estatico.newtype.macros.newtype object Types { @newtype case class Id(value: Long) @newtype case class Username(value: String) } Copy import extras.reflects.syntax.classes._ def infoWithClassTag[A](a: A): Unit = println( s\"\"\"value: $a | type: ${a.nestedClassName} |\"\"\".stripMargin) import Types._ infoWithClassTag(Id(1L)) // value: 1 // type: lang.Long // infoWithClassTag(Username(\"someuser\")) // value: someuser // type: lang.String // println(Id(1L).nestedClassName) // lang.Long println(Username(\"someuser\").nestedClassName) // lang.String Copy "},{"title":"Get extras-scala-io","type":0,"sectionRef":"#","url":"docs/extras-scala-io/getting-started","content":"","keywords":""},{"title":"Get extras-scala-io​","type":1,"pageTitle":"Get extras-scala-io","url":"docs/extras-scala-io/getting-started#get-extras-scala-io-1","content":"\"io.kevinlee\" %% \"extras-scala-io\" % \"0.11.0\" Copy "},{"title":"Usage​","type":1,"pageTitle":"Get extras-scala-io","url":"docs/extras-scala-io/getting-started#usage","content":""}]