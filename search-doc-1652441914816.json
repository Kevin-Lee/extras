[{"title":"extras","type":0,"sectionRef":"#","url":"docs/","content":"extras Project\tMaven Centralextras-cats extras-scala-io extras-concurrent extras-concurrent-testing extras-hedgehog-cats-effect3 extras-reflects extras-refinement info Supported Scala Versions: 3, 2.13, 2.12 and 2.11 Show all extras versions extras-cats \"io.kevinlee\" %% \"extras-cats\" % \"0.14.0\" Copy extras-scala-io \"io.kevinlee\" %% \"extras-scala-io\" % \"0.14.0\" Copy extras-concurrent \"io.kevinlee\" %% \"extras-concurrent\" % \"0.14.0\" Copy \"io.kevinlee\" %% \"extras-concurrent-testing\" % \"0.14.0\" % Test Copy extras-hedgehog-cats-effect3 \"io.kevinlee\" %% \"extras-hedgehog-cats-effect3\" % \"0.14.0\" Copy extras-reflects (n/a to Scala 3) \"io.kevinlee\" %% \"extras-reflects\" % \"0.14.0\" Copy extras-refinement (n/a to Scala 3) \"io.kevinlee\" %% \"extras-refinement\" % \"0.14.0\" Copy","keywords":""},{"title":"Get extras-cats","type":0,"sectionRef":"#","url":"docs/extras-cats/getting-started","content":"Get extras-cats \"io.kevinlee\" %% \"extras-cats\" % \"0.14.0\" Copy","keywords":""},{"title":"OptionT","type":0,"sectionRef":"#","url":"docs/extras-cats/optiont","content":"","keywords":""},{"title":"Extension Methods for OptionT​","type":1,"pageTitle":"OptionT","url":"docs/extras-cats/optiont#extension-methods-for-optiont","content":"import extras.cats.syntax.option._ Copy or import extras.cats.syntax.all._ Copy "},{"title":"optionT / t for F[Option[A]]​","type":1,"pageTitle":"OptionT","url":"docs/extras-cats/optiont#optiont--t-for-foptiona","content":"When you have foa: F[Option[A]], instead of OptionT(foa), you can simply do foa.optionT // OptionT[F, A] // or foa.t // OptionT[F, A] Copy import cats.syntax.all._ import cats.effect._ import extras.cats.syntax.all._ val foa = IO.pure(1.some) // foa: IO[Option[Int]] = Pure(a = Some(value = 1)) foa.t // res1: cats.data.OptionT[IO, Int] = OptionT( // value = Pure(a = Some(value = 1)) // ) val f = IO(println(\"Hello\").some) // f: IO[Option[Unit]] = Delay( // thunk = <function0>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO$.delay(IO.scala:1176), // cats.effect.IO$.apply(IO.scala:1144), // repl.MdocSession$App0$.<clinit>(optiont.md:26), // repl.MdocSession$App.<init>(optiont.md:5), // repl.MdocSession$.app(optiont.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ) f.t // res2: cats.data.OptionT[IO, Unit] = OptionT( // value = Delay( // thunk = <function0>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO$.delay(IO.scala:1176), // cats.effect.IO$.apply(IO.scala:1144), // repl.MdocSession$App0$.<clinit>(optiont.md:26), // repl.MdocSession$App.<init>(optiont.md:5), // repl.MdocSession$.app(optiont.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ) // ) Copy "},{"title":"optionT / t for Option[A]​","type":1,"pageTitle":"OptionT","url":"docs/extras-cats/optiont#optiont--t-for-optiona","content":"When you have oa: Option[A], instead of OptionT.fromOption[F](oa), you can simply do oa.optionT[F] // OptionT[F, A] // or oa.t[F] // OptionT[F, A] Copy import cats.syntax.all._ import cats.effect._ import extras.cats.syntax.all._ val oa = 1.some // oa: Option[Int] = Some(value = 1) oa.t[IO] // res4: cats.data.OptionT[IO, Int] = OptionT( // value = Pure(a = Some(value = 1)) // ) Copy "},{"title":"someT for F[A]​","type":1,"pageTitle":"OptionT","url":"docs/extras-cats/optiont#somet-for-fa","content":"When you have fa: F[A], instead of OptionT.liftF(fa), you can simply do fa.someT // OptionT[F, A] Copy import cats.effect._ import extras.cats.syntax.all._ val fa = IO.pure(1) // fa: IO[Int] = Pure(a = 1) fa.someT // res6: cats.data.OptionT[IO, Int] = OptionT( // value = Map( // source = Pure(a = 1), // f = cats.data.OptionT$$$Lambda$8277/0x0000000102451040@29978aa9, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:872), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:865), // cats.data.OptionT$.liftF(OptionT.scala:249), // extras.cats.syntax.OptionSyntax$OptionTFAOps$.someT$extension(OptionSyntax.scala:37), // repl.MdocSession$App5$.<clinit>(optiont.md:68), // repl.MdocSession$App3$.<clinit>(optiont.md:53), // repl.MdocSession$App0$.<clinit>(optiont.md:32), // repl.MdocSession$App.<init>(optiont.md:5), // repl.MdocSession$.app(optiont.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ) // ) val f = IO(println(\"Hello\")) // f: IO[Unit] = Delay( // thunk = <function0>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO$.delay(IO.scala:1176), // cats.effect.IO$.apply(IO.scala:1144), // repl.MdocSession$App5$.<clinit>(optiont.md:71), // repl.MdocSession$App3$.<clinit>(optiont.md:53), // repl.MdocSession$App0$.<clinit>(optiont.md:32), // repl.MdocSession$App.<init>(optiont.md:5), // repl.MdocSession$.app(optiont.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ) f.someT // res7: cats.data.OptionT[IO, Unit] = OptionT( // value = Map( // source = Delay( // thunk = <function0>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO$.delay(IO.scala:1176), // cats.effect.IO$.apply(IO.scala:1144), // repl.MdocSession$App5$.<clinit>(optiont.md:71), // repl.MdocSession$App3$.<clinit>(optiont.md:53), // repl.MdocSession$App0$.<clinit>(optiont.md:32), // repl.MdocSession$App.<init>(optiont.md:5), // repl.MdocSession$.app(optiont.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ), // f = cats.data.OptionT$$$Lambda$8277/0x0000000102451040@29978aa9, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:872), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:865), // cats.data.OptionT$.liftF(OptionT.scala:249), // extras.cats.syntax.OptionSyntax$OptionTFAOps$.someT$extension(OptionSyntax.scala:37), // ... Copy "},{"title":"someTF for A​","type":1,"pageTitle":"OptionT","url":"docs/extras-cats/optiont#sometf-for-a","content":"When you have a: A, instead of OptionT.some(a), you can simply do a.someTF[F] // OptionT[F, A] Copy import cats.effect._ import extras.cats.syntax.all._ val a = 1 // a: Int = 1 a.someTF[IO] // res9: cats.data.OptionT[IO, Int] = OptionT( // value = Pure(a = Some(value = 1)) // ) Copy "},{"title":"Example​","type":1,"pageTitle":"OptionT","url":"docs/extras-cats/optiont#example","content":"import cats.syntax.all._ import cats.effect._ import extras.cats.syntax.all._ final case class MyError(message: String) def foo[F[_]: Sync](n: Int): F[Int] = Sync[F].pure(n * 2) def bar[F[_]: Sync](n: Int): F[Option[Int]] = if (n < 0) Sync[F].pure(none[Int]) else Sync[F].pure((n + 100).some) def divide[F[_]: Sync](a: Int, b: Int): F[Option[Int]] = if (b == 0) none[Int].pure[F] else Sync[F].delay((a / b).some) def run[F[_]: Sync](): F[Option[Int]] = (for { a <- foo(123).someT b <- 2.someTF[F] c <- bar(b).optionT d <- divide(a, b).t } yield d).value println(run[IO]().unsafeRunSync()) // Some(123) Copy "},{"title":"EitherT","type":0,"sectionRef":"#","url":"docs/extras-cats/eithert","content":"","keywords":""},{"title":"Extension Methods for EitherT​","type":1,"pageTitle":"EitherT","url":"docs/extras-cats/eithert#extension-methods-for-eithert","content":"import extras.cats.syntax.either._ Copy or import extras.cats.syntax.all._ Copy "},{"title":"eitherT / t for F[Either[A, B]]​","type":1,"pageTitle":"EitherT","url":"docs/extras-cats/eithert#eithert--t-for-feithera-b","content":"When you have fab: F[Either[A, B]], instead of EitherT(fab), you can simply do fab.eitherT // EitherT[F, A, B] // or fab.t // EitherT[F, A, B] Copy import cats.syntax.all._ import cats.effect._ import extras.cats.syntax.all._ val fab = IO.pure(1.asRight[String]) // fab: IO[Either[String, Int]] = Pure(a = Right(value = 1)) fab.t // res1: cats.data.EitherT[IO, String, Int] = EitherT( // value = Pure(a = Right(value = 1)) // ) val f = IO(println(\"Hello\").asRight[String]) // f: IO[Either[String, Unit]] = Delay( // thunk = <function0>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO$.delay(IO.scala:1176), // cats.effect.IO$.apply(IO.scala:1144), // repl.MdocSession$App0$.<clinit>(eithert.md:26), // repl.MdocSession$App.<init>(eithert.md:5), // repl.MdocSession$.app(eithert.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ) f.t // res2: cats.data.EitherT[IO, String, Unit] = EitherT( // value = Delay( // thunk = <function0>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO$.delay(IO.scala:1176), // cats.effect.IO$.apply(IO.scala:1144), // repl.MdocSession$App0$.<clinit>(eithert.md:26), // repl.MdocSession$App.<init>(eithert.md:5), // repl.MdocSession$.app(eithert.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ) // ) Copy "},{"title":"eitherT / t for Either[A, B]​","type":1,"pageTitle":"EitherT","url":"docs/extras-cats/eithert#eithert--t-for-eithera-b","content":"When you have ab: Either[A, B], instead of EitherT.fromEither[F](ab), you can simply do ab.eitherT[F] // EitherT[F, A, B] // or ab.t[F] // EitherT[F, A, B] Copy import cats.syntax.all._ import cats.effect._ import extras.cats.syntax.all._ val ab = 1.asRight[String] // ab: Either[String, Int] = Right(value = 1) ab.t[IO] // res4: cats.data.EitherT[IO, String, Int] = EitherT( // value = Pure(a = Right(value = 1)) // ) Copy "},{"title":"rightT for F[B]​","type":1,"pageTitle":"EitherT","url":"docs/extras-cats/eithert#rightt-for-fb","content":"When you have fb: F[B], instead of EitherT.right[A](fb), you can simply do fb.rightT[A] // EitherT[F, A, B] Copy import cats.effect._ import extras.cats.syntax.all._ val fb = IO.pure(1) // fb: IO[Int] = Pure(a = 1) fb.rightT[String] // res6: cats.data.EitherT[IO, String, Int] = EitherT( // value = Map( // source = Pure(a = 1), // f = cats.data.EitherT$RightPartiallyApplied$$$Lambda$8192/0x00000001023c3040@70e18572, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:872), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:865), // cats.data.EitherT$RightPartiallyApplied$.apply$extension(EitherT.scala:694), // extras.cats.syntax.EitherSyntax$EitherTFAOps$.rightT$extension(EitherSyntax.scala:37), // repl.MdocSession$App5$.<clinit>(eithert.md:68), // repl.MdocSession$App3$.<clinit>(eithert.md:53), // repl.MdocSession$App0$.<clinit>(eithert.md:32), // repl.MdocSession$App.<init>(eithert.md:5), // repl.MdocSession$.app(eithert.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ) // ) val f = IO(println(\"Hello\")) // f: IO[Unit] = Delay( // thunk = <function0>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO$.delay(IO.scala:1176), // cats.effect.IO$.apply(IO.scala:1144), // repl.MdocSession$App5$.<clinit>(eithert.md:71), // repl.MdocSession$App3$.<clinit>(eithert.md:53), // repl.MdocSession$App0$.<clinit>(eithert.md:32), // repl.MdocSession$App.<init>(eithert.md:5), // repl.MdocSession$.app(eithert.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ) f.rightT[String] // res7: cats.data.EitherT[IO, String, Unit] = EitherT( // value = Map( // source = Delay( // thunk = <function0>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO$.delay(IO.scala:1176), // cats.effect.IO$.apply(IO.scala:1144), // repl.MdocSession$App5$.<clinit>(eithert.md:71), // repl.MdocSession$App3$.<clinit>(eithert.md:53), // repl.MdocSession$App0$.<clinit>(eithert.md:32), // repl.MdocSession$App.<init>(eithert.md:5), // repl.MdocSession$.app(eithert.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ), // f = cats.data.EitherT$RightPartiallyApplied$$$Lambda$8192/0x00000001023c3040@70e18572, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:872), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:865), // cats.data.EitherT$RightPartiallyApplied$.apply$extension(EitherT.scala:694), // ... Copy "},{"title":"leftT for F[A]​","type":1,"pageTitle":"EitherT","url":"docs/extras-cats/eithert#leftt-for-fa","content":"When you have fa: F[A], instead of EitherT.left[B](fa), you can simply do fa.leftT[B] // EitherT[F, A, B] Copy import cats.effect._ import extras.cats.syntax.all._ val fa = IO.pure(\"ERROR!!!\") // fa: IO[String] = Pure(a = \"ERROR!!!\") fa.leftT[Int] // res9: cats.data.EitherT[IO, String, Int] = EitherT( // value = Map( // source = Pure(a = \"ERROR!!!\"), // f = cats.data.EitherT$LeftPartiallyApplied$$$Lambda$8193/0x00000001023f0040@5d8c853e, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:872), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:865), // cats.data.EitherT$LeftPartiallyApplied$.apply$extension(EitherT.scala:658), // extras.cats.syntax.EitherSyntax$EitherTFAOps$.leftT$extension(EitherSyntax.scala:38), // repl.MdocSession$App8$.<clinit>(eithert.md:92), // repl.MdocSession$App5$.<clinit>(eithert.md:77), // repl.MdocSession$App3$.<clinit>(eithert.md:53), // repl.MdocSession$App0$.<clinit>(eithert.md:32), // repl.MdocSession$App.<init>(eithert.md:5), // repl.MdocSession$.app(eithert.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ) // ) val f = IO(println(\"ERROR!!!\")) // f: IO[Unit] = Delay( // thunk = <function0>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO$.delay(IO.scala:1176), // cats.effect.IO$.apply(IO.scala:1144), // repl.MdocSession$App8$.<clinit>(eithert.md:95), // repl.MdocSession$App5$.<clinit>(eithert.md:77), // repl.MdocSession$App3$.<clinit>(eithert.md:53), // repl.MdocSession$App0$.<clinit>(eithert.md:32), // repl.MdocSession$App.<init>(eithert.md:5), // repl.MdocSession$.app(eithert.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ) f.leftT[Int] // res10: cats.data.EitherT[IO, Unit, Int] = EitherT( // value = Map( // source = Delay( // thunk = <function0>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO$.delay(IO.scala:1176), // cats.effect.IO$.apply(IO.scala:1144), // repl.MdocSession$App8$.<clinit>(eithert.md:95), // repl.MdocSession$App5$.<clinit>(eithert.md:77), // repl.MdocSession$App3$.<clinit>(eithert.md:53), // repl.MdocSession$App0$.<clinit>(eithert.md:32), // repl.MdocSession$App.<init>(eithert.md:5), // repl.MdocSession$.app(eithert.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ), // f = cats.data.EitherT$LeftPartiallyApplied$$$Lambda$8193/0x00000001023f0040@5d8c853e, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:872), // cats.effect.IOLowPriorityInstances$IOEffect.map(IO.scala:865), // cats.data.EitherT$LeftPartiallyApplied$.apply$extension(EitherT.scala:65... Copy "},{"title":"Example​","type":1,"pageTitle":"EitherT","url":"docs/extras-cats/eithert#example","content":"import cats.syntax.all._ import cats.effect._ import extras.cats.syntax.all._ final case class MyError(message: String) def foo[F[_]: Sync](n: Int): F[Int] = Sync[F].pure(n * 2) def bar[F[_]: Sync](n: Int): F[Either[MyError, Int]] = if (n < 0) Sync[F].pure(MyError(s\"n cannot be a negative number. [n: $n]\").asLeft) else Sync[F].pure((n + 100).asRight) def divide[F[_]: Sync](a: Int, b: Int): F[Either[MyError, Int]] = if (b == 0) MyError(s\"You can divide number by 0. [a: $a, b: $b]\").asLeft.pure[F] else Sync[F].delay((a / b).asRight) def run[F[_]: Sync](): F[Either[MyError, Int]] = (for { a <- foo(123).rightT b <- 2.rightTF[F, MyError] c <- bar(b).eitherT d <- divide(a, b).t } yield d).value println(run[IO]().unsafeRunSync()) // Right(123) Copy "},{"title":"Concurrent","type":0,"sectionRef":"#","url":"docs/extras-concurrent/concurrent","content":"Concurrent","keywords":""},{"title":"Get extras-hedgehog-cats-effect3","type":0,"sectionRef":"#","url":"docs/extras-hedgehog-cats-effect3/getting-started","content":"Get extras-hedgehog-cats-effect3 extras-hedgehog-cats-effect3 provides some helper tools to write tests with hedgehog and cats-effect 3. \"io.kevinlee\" %% \"extras-hedgehog-cats-effect3\" % \"0.14.0\" Copy","keywords":""},{"title":"Get extras-concurrent","type":0,"sectionRef":"#","url":"docs/extras-concurrent/getting-started","content":"","keywords":""},{"title":"Get extras-concurrent​","type":1,"pageTitle":"Get extras-concurrent","url":"docs/extras-concurrent/getting-started#get-extras-concurrent-1","content":"\"io.kevinlee\" %% \"extras-concurrent\" % \"0.14.0\" Copy "},{"title":"Get extras-concurrent-testing​","type":1,"pageTitle":"Get extras-concurrent","url":"docs/extras-concurrent/getting-started#get-extras-concurrent-testing","content":"\"io.kevinlee\" %% \"extras-concurrent-testing\" % \"0.14.0\" % Test Copy "},{"title":"Usage​","type":1,"pageTitle":"Get extras-concurrent","url":"docs/extras-concurrent/getting-started#usage","content":""},{"title":"Get extras-refinement","type":0,"sectionRef":"#","url":"docs/extras-refinement/getting-started","content":"Get extras-refinement extras-refinement provides syntax to use newtype and refined. \"io.kevinlee\" %% \"extras-refinement\" % \"0.14.0\" Copy","keywords":""},{"title":"Test with cats-effect 3 IO","type":0,"sectionRef":"#","url":"docs/extras-hedgehog-cats-effect3/test-with-io","content":"","keywords":""},{"title":"completeThen​","type":1,"pageTitle":"Test with cats-effect 3 IO","url":"docs/extras-hedgehog-cats-effect3/test-with-io#completethen","content":"Use CatsEffectRunner and completeThen instead of unsafeRunSync(). import cats.effect._ import extras.hedgehog.cats.effect.CatsEffectRunner import hedgehog._ import hedgehog.runner._ object SomeSpec extends Properties { override def tests: List[Test] = List( property(\"test with CatsEffectRunner and completeThen\", testCatsEffectRunnerWithCompleteThen) ) def testCatsEffectRunnerWithCompleteThen: Property = for { n <- Gen.int(Range.linear(Int.MinValue, Int.MaxValue)).log(\"n\") } yield { import CatsEffectRunner._ implicit val ticker: Ticker = Ticker.withNewTestContext() val expected = n val actual = IO(n) actual.completeThen { actual => actual ==== expected } } } Copy "},{"title":"errorThen​","type":1,"pageTitle":"Test with cats-effect 3 IO","url":"docs/extras-hedgehog-cats-effect3/test-with-io#errorthen","content":"If you want to test with IO which may result in some Exception thrown, you can use errorThen instead of unsafeRunSync() and Try. import cats.effect._ import extras.hedgehog.cats.effect.CatsEffectRunner import hedgehog._ import hedgehog.runner._ object SomeSpec extends Properties { override def tests: List[Test] = List( property(\"test with CatsEffectRunner and errorThen\", testCatsEffectRunnerWithErrorThen) ) def testCatsEffectRunnerWithErrorThen: Property = for { message <- Gen.string(Gen.alphaNum, Range.linear(1, 10)).log(\"message\") error <- Gen .element1( TestError.someTestError(s\"Don't worry it's only a test error. $message\"), TestError.anotherTestError(s\"Don't worry it's only a test error. $message\") ) .log(\"error\") } yield { import CatsEffectRunner._ implicit val ticker: Ticker = Ticker.withNewTestContext() val expected = error val actual = IO.raiseError[Int](error) actual.errorThen { actual => actual ==== expected } } sealed abstract class TestError(val message: String) extends RuntimeException(message) object TestError { final case class SomeTestError(override val message: String) extends TestError(message) final case class AnotherTestError(override val message: String) extends TestError(message) def anotherTestError(message: String): TestError = AnotherTestError(message) def someTestError(message: String): TestError = SomeTestError(message) } } Copy "},{"title":"Get extras-reflects","type":0,"sectionRef":"#","url":"docs/extras-reflects/getting-started","content":"Get extras-reflects extras-reflects provides convenient syntax to use scala-reflect. \"io.kevinlee\" %% \"extras-reflects\" % \"0.14.0\" Copy","keywords":""},{"title":"Refinement Syntax","type":0,"sectionRef":"#","url":"docs/extras-refinement/syntax","content":"","keywords":""},{"title":"Why refinement syntax?​","type":1,"pageTitle":"Refinement Syntax","url":"docs/extras-refinement/syntax#why-refinement-syntax","content":"When you use newtype and refined together to have better type-safety, you often have some boilerplate code for runtime value validation when creating newtype + refinement type just like this. YourRefinementType.from(value) .map(YourNewtype(_)) .leftMap(err => s\"Failed to create YourNewtype: $err\") .toEitherNec Copy There are a few issues here. First, you need to create your newtype with the newtype constructor and the validated value. e.g.) .map(YourNewType(_))If it is invalid, you probably want to add the type name for debugging with leftMap. e.g.) .leftMap(err => s\"Failed to create YourNewtype: $err\")Finally, depending on how to validate, you probably turn the Either[String, YourNewType] from the validation into EitherNec since you may want to accumulate all the errors from multiple validations. e.g.) .toEitherNec In practice, it may look like import cats.syntax.all._ import io.estatico.newtype.macros.newtype import eu.timepit.refined.types.string.NonEmptyString @newtype case class Name(value: NonEmptyString) val validNameValue = \"Kevin\" // validNameValue: String = \"Kevin\" NonEmptyString.from(validNameValue) .map(Name(_)) .leftMap(err => s\"Failed to create Name: $err\") .toEitherNec // res1: cats.data.package.EitherNec[String, Name] = Right(value = Kevin) val invalidNameValue = \"\" // invalidNameValue: String = \"\" NonEmptyString.from(invalidNameValue) .map(Name(_)) .leftMap(err => s\"Failed to create Name: $err\") .toEitherNec // res2: cats.data.package.EitherNec[String, Name] = Left( // value = Singleton( // a = \"Failed to create Name: Predicate isEmpty() did not fail.\" // ) // ) Copy or this import cats.syntax.all._ import eu.timepit.refined.api._ import eu.timepit.refined.numeric._ import eu.timepit.refined.types.string.NonEmptyString import io.estatico.newtype.macros.newtype import io.estatico.newtype.ops._ object Types { type PositiveInt = Int Refined Positive object PositiveInt extends RefinedTypeOps[PositiveInt, Int] @newtype case class Id(value: PositiveInt) @newtype case class Name(value: NonEmptyString) final case class Person(id: Id, name: Name) } import Types._ val idValue = 999 // idValue: Int = 999 val id = PositiveInt.from(idValue) .map(Id(_)) .leftMap(err => s\"Failed to create Types.Id: $err\") .toEitherNec // id: cats.data.package.EitherNec[String, Id] = Right(value = 999) println(id) // Right(999) val nameValue = \"Kevin\" // nameValue: String = \"Kevin\" val name = NonEmptyString.from(nameValue) .map(Name(_)) .leftMap(err => s\"Failed to create Types.Name: $err\") .toEitherNec // name: cats.data.package.EitherNec[String, Name] = Right(value = Kevin) println(name) // Right(Kevin) val person = (id, name).parMapN(Person.apply) // person: cats.data.package.EitherNec[String, Person] = Right( // value = Person(id = 999, name = Kevin) // ) println(person) // Right(Person(999,Kevin)) Copy or invalid case like val idValue2 = 0 // idValue2: Int = 0 val id2 = PositiveInt.from(idValue2) .map(Id(_)) .leftMap(err => s\"Failed to create Types.Id: $err\") .toEitherNec // id2: cats.data.package.EitherNec[String, Id] = Left( // value = Singleton(a = \"Failed to create Types.Id: Predicate failed: (0 > 0).\") // ) println(id2) // Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0).)) val nameValue2 = \"\" // nameValue2: String = \"\" val name2 = NonEmptyString.from(nameValue2) .map(Name(_)) .leftMap(err => s\"Failed to create Types.Name: $err\") .toEitherNec // name2: cats.data.package.EitherNec[String, Name] = Left( // value = Singleton( // a = \"Failed to create Types.Name: Predicate isEmpty() did not fail.\" // ) // ) println(name2) // Left(Chain(Failed to create Types.Name: Predicate isEmpty() did not fail.)) val person2 = (id2, name2).parMapN(Person.apply) // person2: cats.data.package.EitherNec[String, Person] = Left( // value = Append( // leftNE = Singleton( // a = \"Failed to create Types.Id: Predicate failed: (0 > 0).\" // ), // rightNE = Singleton( // a = \"Failed to create Types.Name: Predicate isEmpty() did not fail.\" // ) // ) // ) println(person2) // Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0)., Failed to create Types.Name: Predicate isEmpty() did not fail.)) Copy "},{"title":"refinement syntax​","type":1,"pageTitle":"Refinement Syntax","url":"docs/extras-refinement/syntax#refinement-syntax","content":"The boilerplate code issue in newtype + refinement type creation can be fixed with extras refinement syntax so the following code YourRefinementType.from(value) .map(YourNewtype(_)) .leftMap(err => s\"Failed to create YourNewtype: $err\") .toEitherNec Copy becomes just validateAs[YourNewtype](value) Copy or value.validateAs[YourNewtype] Copy note The idea of validateAs[A](value) and value.validateAs[A] is from Practical FP in Scala. The syntax is not exactly the same, but the most important core logic of using Coercible is the same. If you are interested in the difference, the source code from Practical FP in Scala is here andthe source code of extras-refinement is here "},{"title":"Example: Valid Case​","type":1,"pageTitle":"Refinement Syntax","url":"docs/extras-refinement/syntax#example-valid-case","content":"import cats.syntax.all._ import eu.timepit.refined.api._ import eu.timepit.refined.numeric._ import eu.timepit.refined.types.string.NonEmptyString import io.estatico.newtype.macros.newtype import extras.refinement.syntax.refinement._ object Types { type PositiveInt = Int Refined Positive object PositiveInt extends RefinedTypeOps[PositiveInt, Int] @newtype case class Id(value: PositiveInt) @newtype case class Name(value: NonEmptyString) final case class Person(id: Id, name: Name) } import Types._ val idValue = 999 // idValue: Int = 999 val id = validateAs[Id](idValue) // id: cats.data.package.EitherNec[String, Id] = Right(value = 999) val id2 = idValue.validateAs[Id] // id2: cats.data.package.EitherNec[String, Id] = Right(value = 999) println(id) // Right(999) println(id2) // Right(999) val nameValue = \"Kevin\" // nameValue: String = \"Kevin\" val name = validateAs[Name](nameValue) // name: cats.data.package.EitherNec[String, Name] = Right(value = Kevin) val name2 = nameValue.validateAs[Name] // name2: cats.data.package.EitherNec[String, Name] = Right(value = Kevin) println(name) // Right(Kevin) println(name2) // Right(Kevin) val person = (id, name).parMapN(Person.apply) // person: cats.data.package.EitherNec[String, Person] = Right( // value = Person(id = 999, name = Kevin) // ) println(person) // Right(Person(999,Kevin)) Copy "},{"title":"Example: Invalid Case​","type":1,"pageTitle":"Refinement Syntax","url":"docs/extras-refinement/syntax#example-invalid-case","content":"Only of them is invalid​ import cats.syntax.all._ import eu.timepit.refined.api._ import eu.timepit.refined.numeric._ import eu.timepit.refined.types.string.NonEmptyString import io.estatico.newtype.macros.newtype import extras.refinement.syntax.refinement._ object Types { type PositiveInt = Int Refined Positive object PositiveInt extends RefinedTypeOps[PositiveInt, Int] @newtype case class Id(value: PositiveInt) @newtype case class Name(value: NonEmptyString) final case class Person(id: Id, name: Name) } import Types._ val idValue = 0 // idValue: Int = 0 val id = validateAs[Id](idValue) // id: cats.data.package.EitherNec[String, Id] = Left( // value = Singleton(a = \"Failed to create Types.Id: Predicate failed: (0 > 0).\") // ) val id2 = idValue.validateAs[Id] // id2: cats.data.package.EitherNec[String, Id] = Left( // value = Singleton(a = \"Failed to create Types.Id: Predicate failed: (0 > 0).\") // ) println(id) // Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0).)) println(id2) // Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0).)) val nameValue = \"Kevin\" // nameValue: String = \"Kevin\" val name = validateAs[Name](nameValue) // name: cats.data.package.EitherNec[String, Name] = Right(value = Kevin) val name2 = nameValue.validateAs[Name] // name2: cats.data.package.EitherNec[String, Name] = Right(value = Kevin) println(name) // Right(Kevin) println(name2) // Right(Kevin) val person = (id, name).parMapN(Person.apply) // person: cats.data.package.EitherNec[String, Person] = Left( // value = Singleton(a = \"Failed to create Types.Id: Predicate failed: (0 > 0).\") // ) println(person) // Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0).)) Copy The other one is invalid​ import cats.syntax.all._ import eu.timepit.refined.api._ import eu.timepit.refined.numeric._ import eu.timepit.refined.types.string.NonEmptyString import io.estatico.newtype.macros.newtype import extras.refinement.syntax.refinement._ object Types { type PositiveInt = Int Refined Positive object PositiveInt extends RefinedTypeOps[PositiveInt, Int] @newtype case class Id(value: PositiveInt) @newtype case class Name(value: NonEmptyString) final case class Person(id: Id, name: Name) } import Types._ val idValue = 999 // idValue: Int = 999 val id = validateAs[Id](idValue) // id: cats.data.package.EitherNec[String, Id] = Right(value = 999) val id2 = idValue.validateAs[Id] // id2: cats.data.package.EitherNec[String, Id] = Right(value = 999) println(id) // Right(999) println(id2) // Right(999) val nameValue = \"\" // nameValue: String = \"\" val name = validateAs[Name](nameValue) // name: cats.data.package.EitherNec[String, Name] = Left( // value = Singleton( // a = \"Failed to create Types.Name: Predicate isEmpty() did not fail.\" // ) // ) val name2 = nameValue.validateAs[Name] // name2: cats.data.package.EitherNec[String, Name] = Left( // value = Singleton( // a = \"Failed to create Types.Name: Predicate isEmpty() did not fail.\" // ) // ) println(name) // Left(Chain(Failed to create Types.Name: Predicate isEmpty() did not fail.)) println(name2) // Left(Chain(Failed to create Types.Name: Predicate isEmpty() did not fail.)) val person = (id, name).parMapN(Person.apply) // person: cats.data.package.EitherNec[String, Person] = Left( // value = Singleton( // a = \"Failed to create Types.Name: Predicate isEmpty() did not fail.\" // ) // ) println(person) // Left(Chain(Failed to create Types.Name: Predicate isEmpty() did not fail.)) Copy More than one invalid​ import cats.syntax.all._ import eu.timepit.refined.api._ import eu.timepit.refined.numeric._ import eu.timepit.refined.types.string.NonEmptyString import io.estatico.newtype.macros.newtype import extras.refinement.syntax.refinement._ object Types { type PositiveInt = Int Refined Positive object PositiveInt extends RefinedTypeOps[PositiveInt, Int] @newtype case class Id(value: PositiveInt) @newtype case class Name(value: NonEmptyString) final case class Person(id: Id, name: Name) } import Types._ val idValue = 0 // idValue: Int = 0 val id = validateAs[Id](idValue) // id: cats.data.package.EitherNec[String, Id] = Left( // value = Singleton(a = \"Failed to create Types.Id: Predicate failed: (0 > 0).\") // ) val id2 = idValue.validateAs[Id] // id2: cats.data.package.EitherNec[String, Id] = Left( // value = Singleton(a = \"Failed to create Types.Id: Predicate failed: (0 > 0).\") // ) println(id) // Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0).)) println(id2) // Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0).)) val nameValue = \"\" // nameValue: String = \"\" val name = validateAs[Name](nameValue) // name: cats.data.package.EitherNec[String, Name] = Left( // value = Singleton( // a = \"Failed to create Types.Name: Predicate isEmpty() did not fail.\" // ) // ) val name2 = nameValue.validateAs[Name] // name2: cats.data.package.EitherNec[String, Name] = Left( // value = Singleton( // a = \"Failed to create Types.Name: Predicate isEmpty() did not fail.\" // ) // ) println(name) // Left(Chain(Failed to create Types.Name: Predicate isEmpty() did not fail.)) println(name2) // Left(Chain(Failed to create Types.Name: Predicate isEmpty() did not fail.)) val person = (id, name).parMapN(Person.apply) // person: cats.data.package.EitherNec[String, Person] = Left( // value = Append( // leftNE = Singleton( // a = \"Failed to create Types.Id: Predicate failed: (0 > 0).\" // ), // rightNE = Singleton( // a = \"Failed to create Types.Name: Predicate isEmpty() did not fail.\" // ) // ) // ) println(person) // Left(Chain(Failed to create Types.Id: Predicate failed: (0 > 0)., Failed to create Types.Name: Predicate isEmpty() did not fail.)) Copy "},{"title":"Reflects Syntax","type":0,"sectionRef":"#","url":"docs/extras-reflects/syntax","content":"","keywords":""},{"title":"reflects syntax for WeakTypeTag​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#reflects-syntax-for-weaktypetag","content":""},{"title":"value.nestedTypeName​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#valuenestedtypename","content":"import java.time._ sealed trait Status object Status { final case class InProgress(startedAt: Instant) extends Status case object Done extends Status def inProgress(startedAt: Instant): Status = InProgress(startedAt) def done: Status = Done } Copy import scala.reflect.runtime.universe._ import extras.reflects.syntax.tags._ def infoWithWeakTypeTag[A: WeakTypeTag](a: A): Unit = println( s\"\"\"value: $a | type: ${weakTypeTag[A].nestedTypeName} |\"\"\".stripMargin) infoWithWeakTypeTag(Status.inProgress(Instant.now())) // value: InProgress(2022-05-13T11:38:15.485331Z) // type: App0.Status // infoWithWeakTypeTag(Status.InProgress(Instant.now())) // value: InProgress(2022-05-13T11:38:15.543719Z) // type: Status.InProgress // infoWithWeakTypeTag(Status.done) // value: Done // type: App0.Status // infoWithWeakTypeTag(Status.Done) // value: Done // type: Status.Done // Copy "},{"title":"WeakTypeTag[A].nestedTypeName​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#weaktypetaganestedtypename","content":"import java.time._ sealed trait Status object Status { final case class InProgress(startedAt: Instant) extends Status case object Done extends Status def inProgress(startedAt: Instant): Status = InProgress(startedAt) def done: Status = Done } Copy import scala.reflect.runtime.universe._ import extras.reflects.syntax.tags._ def infoWithWeakTypeTag[A](implicit weakTypeTag: WeakTypeTag[A]): Unit = println( s\"\"\"type: ${weakTypeTag.nestedTypeName} |\"\"\".stripMargin) infoWithWeakTypeTag[Status.InProgress] // type: Status.InProgress // infoWithWeakTypeTag[Status.Done.type] // type: Status.Done // println(weakTypeTag[Status.InProgress].nestedTypeName) // Status.InProgress println(weakTypeTag[Status.Done.type].nestedTypeName) // Status.Done Copy "},{"title":"Works for @newtype​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#works-for-newtype","content":"It works for newtype as well. If you use newtype and want to get the newtype name, WeakTypeTag syntax is what you should use since you can get the name of newtype with it. An example showing that it works with @newtype: import io.estatico.newtype.macros.newtype object Types { @newtype case class Id(value: Long) @newtype case class Username(value: String) } Copy import scala.reflect.runtime.universe._ import extras.reflects.syntax.tags._ Copy def infoWithClassTag[A](a: A)(implicit weakTypeTag: WeakTypeTag[A]): Unit = println( s\"\"\"value: $a | type: ${weakTypeTag.nestedTypeName} |\"\"\".stripMargin) import Types._ infoWithClassTag(Id(1L)) // value: 1 // type: Types.Id // infoWithClassTag(Username(\"someuser\")) // value: someuser // type: Types.Username // println(weakTypeTag[Id].nestedTypeName) // Types.Id println(weakTypeTag[Username].nestedTypeName) // Types.Username Copy "},{"title":"reflects syntax for ClassTag​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#reflects-syntax-for-classtag","content":""},{"title":"value.nestedRuntimeClassName​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#valuenestedruntimeclassname","content":"import java.time._ sealed trait Status object Status { final case class InProgress(startedAt: Instant) extends Status case object Done extends Status def inProgress(startedAt: Instant): Status = InProgress(startedAt) def done: Status = Done } Copy import extras.reflects.syntax.tags._ def infoWithClassTag[A](a: A): Unit = println( s\"\"\"value: $a | type: ${a.nestedRuntimeClassName} |\"\"\".stripMargin) infoWithClassTag(Status.inProgress(Instant.now())) // value: InProgress(2022-05-13T11:38:15.563017Z) // type: Status.InProgress // infoWithClassTag(Status.InProgress(Instant.now())) // value: InProgress(2022-05-13T11:38:15.565119Z) // type: Status.InProgress // infoWithClassTag(Status.done) // value: Done // type: Status.Done // infoWithClassTag(Status.Done) // value: Done // type: Status.Done // Copy println(Status.inProgress(Instant.now()).nestedRuntimeClassName) // Status.InProgress println(Status.InProgress(Instant.now()).nestedRuntimeClassName) // Status.InProgress println(Status.done.nestedRuntimeClassName) // Status.Done println(Status.Done.nestedRuntimeClassName) // Status.Done Copy "},{"title":"ClassTag[A].nestedRuntimeClassName​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#classtaganestedruntimeclassname","content":"import java.time._ sealed trait Status object Status { final case class InProgress(startedAt: Instant) extends Status case object Done extends Status def inProgress(startedAt: Instant): Status = InProgress(startedAt) def done: Status = Done } Copy import scala.reflect.{classTag, ClassTag} import extras.reflects.syntax.tags._ def infoWithClassTag[A](implicit classTag: ClassTag[A]): Unit = println( s\"\"\"type: ${classTag.nestedRuntimeClassName} |\"\"\".stripMargin) infoWithClassTag[Status.InProgress] // type: Status.InProgress // infoWithClassTag[Status.Done.type] // type: Status.Done // Copy println(classTag[Status.InProgress].nestedRuntimeClassName) // Status.InProgress println(classTag[Status.Done.type].nestedRuntimeClassName) // Status.Done Copy "},{"title":"Do not use for @newtype​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#do-not-use-for-newtype","content":"Do not use it for newtype. If you use newtype and want to get the newtype name, ClassTag syntax is not the one you should use since you can get only the actual type not newtype. For @newtype, please use 'reflects syntax for WeakTypeTag'. An example showing that it does not work with @newtype: import io.estatico.newtype.macros.newtype object Types { @newtype case class Id(value: Long) @newtype case class Username(value: String) } Copy import extras.reflects.syntax.tags._ def infoWithClassTag[A](a: A): Unit = println( s\"\"\"value: $a | type: ${a.nestedRuntimeClassName} |\"\"\".stripMargin) import Types._ infoWithClassTag(Id(1L)) // value: 1 // type: lang.Long // infoWithClassTag(Username(\"someuser\")) // value: someuser // type: lang.String // println(Id(1L).nestedRuntimeClassName) // lang.Long println(Username(\"someuser\").nestedRuntimeClassName) // lang.String Copy "},{"title":"reflects syntax for Class​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#reflects-syntax-for-class","content":""},{"title":"value.nestedClassName​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#valuenestedclassname","content":"import java.time._ sealed trait Status object Status { final case class InProgress(startedAt: Instant) extends Status case object Done extends Status def inProgress(startedAt: Instant): Status = InProgress(startedAt) def done: Status = Done } Copy import extras.reflects.syntax.classes._ def infoWithClass[A](a: A): Unit = println( s\"\"\"value: $a | type: ${a.nestedClassName} |\"\"\".stripMargin) infoWithClass(Status.inProgress(Instant.now())) // value: InProgress(2022-05-13T11:38:15.574070Z) // type: Status.InProgress // infoWithClass(Status.InProgress(Instant.now())) // value: InProgress(2022-05-13T11:38:15.575300Z) // type: Status.InProgress // infoWithClass(Status.done) // value: Done // type: Status.Done // infoWithClass(Status.Done) // value: Done // type: Status.Done // Copy println(Status.inProgress(Instant.now()).nestedClassName) // Status.InProgress println(Status.InProgress(Instant.now()).nestedClassName) // Status.InProgress println(Status.done.nestedClassName) // Status.Done println(Status.Done.nestedClassName) // Status.Done Copy "},{"title":"Class[A].nestedClassName​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#classanestedclassname","content":"import java.time._ sealed trait Status object Status { final case class InProgress(startedAt: Instant) extends Status case object Done extends Status def inProgress(startedAt: Instant): Status = InProgress(startedAt) def done: Status = Done } Copy import extras.reflects.syntax.classes._ def infoWithClass[A](aClass: Class[A]): Unit = println( s\"\"\"type: ${aClass.nestedClassName} |\"\"\".stripMargin) infoWithClass(Status.InProgress.getClass) // type: Status.InProgress // infoWithClass(Status.Done.getClass) // type: Status.Done // Copy "},{"title":"Do not use for @newtype​","type":1,"pageTitle":"Reflects Syntax","url":"docs/extras-reflects/syntax#do-not-use-for-newtype-1","content":"Do not use it for newtype. If you use newtype and want to get the newtype name, Class syntax is not the one you should use since you can get only the actual type not newtype. For @newtype, please use 'reflects syntax for WeakTypeTag'. An example showing that it does not work with @newtype: import io.estatico.newtype.macros.newtype object Types { @newtype case class Id(value: Long) @newtype case class Username(value: String) } Copy import extras.reflects.syntax.classes._ def infoWithClassTag[A](a: A): Unit = println( s\"\"\"value: $a | type: ${a.nestedClassName} |\"\"\".stripMargin) import Types._ infoWithClassTag(Id(1L)) // value: 1 // type: lang.Long // infoWithClassTag(Username(\"someuser\")) // value: someuser // type: lang.String // println(Id(1L).nestedClassName) // lang.Long println(Username(\"someuser\").nestedClassName) // lang.String Copy "},{"title":"File","type":0,"sectionRef":"#","url":"docs/extras-scala-io/file","content":"","keywords":""},{"title":"syntax​","type":1,"pageTitle":"File","url":"docs/extras-scala-io/file#syntax","content":""},{"title":"listAllFilesRecursively​","type":1,"pageTitle":"File","url":"docs/extras-scala-io/file#listallfilesrecursively","content":"listAllFilesRecursively in import extras.scala.io.file.syntax listAllFilesRecursively returns all files and directories in the given File as well as the given file itself if it is a directory.If it's a file, it returns a List containing the given File. note The result of listAllFilesRecursively is not sorted, so you need to sort it yourself. e.g.) listAllFilesRecursively(\"path/to/file\").sorted Copy e.g.) If the file structure looks like this  /tmp/a ├──  b │ ├──  b-1 │ │ ├──  b-1-1.txt │ │ ├──  b-1-2.txt │ │ └──  b-1-3.txt │ └──  b-2 │ ├──  b-2-1 │ │ ├──  b-2-1-1.txt │ │ └──  b-2-1-2.txt │ └──  b-2-2 ├──  c │ └──  c-1.txt └──  d ├──  d-1 │ ├──  d-1-1.txt │ ├──  d-1-2.txt │ ├──  d-1-3.txt │ ├──  d-1-4.txt │ └──  d-1-5.txt ├──  d-2.txt └──  d-3.txt Copy the result of listAllFilesRecursively looks like this. import extras.scala.io.file.syntax._ import java.io.File listAllFilesRecursively(new File(\"/tmp/a\")).sorted // List( // /tmp/a, // /tmp/a/b, // /tmp/a/b/b-1, // /tmp/a/b/b-1/b-1-1.txt, // /tmp/a/b/b-1/b-1-2.txt, // /tmp/a/b/b-1/b-1-3.txt, // /tmp/a/b/b-2, // /tmp/a/b/b-2/b-2-1, // /tmp/a/b/b-2/b-2-1/b-2-1-1.txt, // /tmp/a/b/b-2/b-2-1/b-2-1-2.txt, // /tmp/a/b/b-2/b-2-2, // /tmp/a/c, // /tmp/a/c/c-1.txt, // /tmp/a/d, // /tmp/a/d/d-1, // /tmp/a/d/d-1/d-1-1.txt, // /tmp/a/d/d-1/d-1-2.txt, // /tmp/a/d/d-1/d-1-3.txt, // /tmp/a/d/d-1/d-1-4.txt, // /tmp/a/d/d-1/d-1-5.txt, // /tmp/a/d/d-2.txt, // /tmp/a/d/d-3.txt // ) Copy or new File(\"/tmp/a\").listAllFilesRecursively.sorted Copy "},{"title":"deleteAllRecursively​","type":1,"pageTitle":"File","url":"docs/extras-scala-io/file#deleteallrecursively","content":"deleteAllRecursively in import extras.scala.io.file.syntax removes the given file and all the files and directories in it if the given file is a directory. e.g.) If the file structure looks like this  /tmp/a ├──  b │ ├──  b-1 │ │ ├──  b-1-1.txt │ │ ├──  b-1-2.txt │ │ └──  b-1-3.txt │ └──  b-2 │ ├──  b-2-1 │ │ ├──  b-2-1-1.txt │ │ └──  b-2-1-2.txt │ └──  b-2-2 ├──  c │ └──  c-1.txt └──  d ├──  d-1 │ ├──  d-1-1.txt │ ├──  d-1-2.txt │ ├──  d-1-3.txt │ ├──  d-1-4.txt │ └──  d-1-5.txt ├──  d-2.txt └──  d-3.txt Copy deleteAllRecursively deletes the given file and everything in it. import extras.scala.io.file.syntax._ import java.io.File deleteAllRecursively(new File(\"/tmp/a\")) // The `/tmp/a` and everything inside is removed. Copy or new File(\"/tmp/a\").deleteAllRecursively() Copy "},{"title":"TempFiles​","type":1,"pageTitle":"File","url":"docs/extras-scala-io/file#tempfiles","content":""},{"title":"runWithTempDir​","type":1,"pageTitle":"File","url":"docs/extras-scala-io/file#runwithtempdir","content":"If you want to do something any temporary folder which should be deleted once it's done, you can use extras.scala.io.file.TempFiles.runWithTempDir. import extras.scala.io.file.TempFiles import java.io.File def foo(file: File): Unit = if (file.exists) println(s\"${file.getParentFile.getName}/${file.getName} exists\") else println(s\"${file.getParentFile.getName}/${file.getName} does not exist.\") var tmp: Option[File] = None // tmp: Option[File] = None TempFiles.runWithTempDir(\"temporary-dir-prefix\") { tempDir => tmp = Some(tempDir.value) // To check if the directory exists outside this block. tmp.foreach(foo) val tmpDir = tempDir.value val someFile = new File(tmpDir, \"myfile.txt\") someFile.createNewFile() foo(someFile) val someFile2 = new File(tmpDir, \"myfile2.txt\") foo(someFile2) \"Done\" } // tmp/temporary-dir-prefix5654792079430314890 exists // temporary-dir-prefix5654792079430314890/myfile.txt exists // temporary-dir-prefix5654792079430314890/myfile2.txt does not exist. // res1: Either[Throwable, String] = Right(value = \"Done\") tmp.foreach{ file => println(s\"${file.getParentFile.getName}/${file.getName}\") foo(file) } // tmp/temporary-dir-prefix5654792079430314890 // tmp/temporary-dir-prefix5654792079430314890 does not exist. Copy tempDir is of type TempDir which is just this value class. final case class TempDir(value: java.io.File) extends AnyVal Copy TempFiles.runWithTempDir is useful when you test with files and need to remove them once the test is done. Example: test with hedgehog​ import hedgehog._ import hedgehog.runner._ import extras.scala.io.file.TempFiles import java.io._ import scala.util.Using object MyTest extends Properties { def tests: List[Test] = List( property(\"test something with files\", testSomethingWithFiles) ) def testSomethingWithFiles: Property = for { filename <- Gen.string(Gen.alphaNum, Range.linear(3, 5)).log(\"filename\") content1 <- Gen.string(Gen.alphaNum, Range.linear(10, 100)).log(\"content1\") content2 <- Gen.string(Gen.alphaNum, Range.linear(10, 100)).log(\"content2\") } yield { val content = s\"$content1\\n$content2\" TempFiles.runWithTempDir(\"my-temp-dir\") { tempDir => val rootDir = tempDir.value val file = new File(rootDir, filename) (for { _ <- Using(new PrintWriter(file))(_.write(content)) result <- Using(scala.io.Source.fromFile(file))(_.mkString) } yield result).toEither }.joinRight match { case Right(actual) => actual ==== content case Left(err) => Result.failure.log(s\"Failed: ${err.getMessage}\") } } } Copy "},{"title":"Color","type":0,"sectionRef":"#","url":"docs/extras-scala-io/color","content":"","keywords":""},{"title":"extras.scala.io.syntax​","type":1,"pageTitle":"Color","url":"docs/extras-scala-io/color#extrasscalaiosyntax","content":"extras-scala-io provides syntax to use scala.io.AnsiColor easily (The missing ones will be added later). import extras.scala.io.syntax.color._ \"Hello\".blue // res1: String = \"\\u001b[34mHello\\u001b[0m\" \"Hello\".red // res2: String = \"\\u001b[31mHello\\u001b[0m\" \"Hello\".green // res3: String = \"\\u001b[32mHello\\u001b[0m\" \"Hello\".bold // res4: String = \"\\u001b[1mHello\\u001b[0m\" \"Hello\".underlined // res5: String = \"\\u001b[4mHello\\u001b[0m\" println(\"Hello\".blue) // \u001b[34mHello\u001b[0m println(\"Hello\".red) // \u001b[31mHello\u001b[0m println(\"Hello\".green) // \u001b[32mHello\u001b[0m println(\"Hello\".bold) // \u001b[1mHello\u001b[0m println(\"Hello\".underlined) // \u001b[4mHello\u001b[0m Copy  You can also chain them like this. import extras.scala.io.syntax.color._ println(\"Hello\".blue) // \u001b[34mHello\u001b[0m println(\"Hello\".blue.bold) // \u001b[1m\u001b[34mHello\u001b[0m\u001b[0m println(\"Hello\".blue.bold.underlined) // \u001b[4m\u001b[1m\u001b[34mHello\u001b[0m\u001b[0m\u001b[0m println(\"Hello\".underlined.bold.blue) // \u001b[34m\u001b[1m\u001b[4mHello\u001b[0m\u001b[0m\u001b[0m Copy  "},{"title":"Get extras-scala-io","type":0,"sectionRef":"#","url":"docs/extras-scala-io/getting-started","content":"","keywords":""},{"title":"Get extras-scala-io​","type":1,"pageTitle":"Get extras-scala-io","url":"docs/extras-scala-io/getting-started#get-extras-scala-io-1","content":"\"io.kevinlee\" %% \"extras-scala-io\" % \"0.14.0\" Copy "},{"title":"Usage​","type":1,"pageTitle":"Get extras-scala-io","url":"docs/extras-scala-io/getting-started#usage","content":""}]